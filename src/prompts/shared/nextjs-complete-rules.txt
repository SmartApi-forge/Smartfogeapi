â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
COMPLETE NEXT.JS 15+ APP ROUTER RULES - FOLLOW EXACTLY
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

<server_vs_client_components>

## SERVER COMPONENTS (Default)

### âœ… ALLOWED:
- async/await functions
- Direct database access
- Reading environment variables (all)
- Server-side API calls
- File system operations
- Importing server-only packages
- Using cookies() and headers()
- Streaming with Suspense

### âŒ NOT ALLOWED:
- React hooks (useState, useEffect, useContext, etc.)
- Event handlers (onClick, onChange, onSubmit, etc.)
- Browser APIs (window, document, localStorage, etc.)
- useRouter from 'next/navigation' (use redirect() instead)
- Client-side libraries (react-hook-form in component directly)

### Example SERVER Component:
```tsx
// app/users/page.tsx
import { db } from '@/lib/db';

export default async function UsersPage() {
  // âœ… Can use async/await
  const users = await db.user.findMany();
  
  // âœ… Can access env vars
  const apiKey = process.env.API_KEY;
  
  return (
    <div>
      {users.map(user => (
        <div key={user.id}>{user.name}</div>
      ))}
    </div>
  );
}
```

## CLIENT COMPONENTS (Opt-in with "use client")

### âœ… ALLOWED:
- All React hooks
- Event handlers
- Browser APIs
- State management
- Client-side routing (useRouter, usePathname, useSearchParams)
- Third-party libraries that use hooks

### âŒ NOT ALLOWED:
- Direct database access
- Server-only packages
- Reading non-NEXT_PUBLIC_ env vars
- Using cookies() and headers() directly

### ğŸš¨ CRITICAL: "use client" SYNTAX

**CORRECT**:
```tsx
"use client";  // âœ… FIRST line, directive (not import!)

import { useState } from "react";
```

**WRONG**:
```tsx
import "use client";  // âŒ NOT an import
import 'use client';  // âŒ NOT an import
// "use client";      // âŒ NOT a comment

import { useState } from "react";
"use client";         // âŒ NOT first line
```

</server_vs_client_components>

<common_errors_and_fixes>

## ERROR 1: "You're importing a component that needs X. It only works in a Client Component"

**Cause**: Using hooks/events in a Server Component

**Example**:
```tsx
// app/page.tsx (Server Component by default)
import { useState } from "react"; // âŒ This will cause error

export default function Page() {
  const [count, setCount] = useState(0); // âŒ Error!
  return <div>{count}</div>;
}
```

**FIX**: Add "use client" as FIRST line
```tsx
"use client"; // âœ… Added

import { useState } from "react";

export default function Page() {
  const [count, setCount] = useState(0); // âœ… Works now
  return <div>{count}</div>;
}
```

## ERROR 2: "useRouter only works in Client Components"

**Cause**: Using useRouter from 'next/navigation' in Server Component

**Example**:
```tsx
// app/page.tsx (Server Component)
import { useRouter } from 'next/navigation';

export default function Page() {
  const router = useRouter(); // âŒ Error!
  return <div>Page</div>;
}
```

**FIX Option 1**: Add "use client"
```tsx
"use client"; // âœ… Added

import { useRouter } from 'next/navigation';

export default function Page() {
  const router = useRouter(); // âœ… Works
  return <div>Page</div>;
}
```

**FIX Option 2**: Use redirect() for Server Components
```tsx
import { redirect } from 'next/navigation';

export default function Page() {
  // For server-side redirects
  redirect('/other-page');
}
```

## ERROR 3: "Hydration failed because the initial UI does not match"

**Cause**: Server and client render different content

**Example**:
```tsx
export default function Page() {
  return <div>{new Date().toString()}</div>; // âŒ Different on server/client
}
```

**FIX**: Use useEffect or suppressHydrationWarning
```tsx
"use client";

import { useState, useEffect } from "react";

export default function Page() {
  const [date, setDate] = useState("");
  
  useEffect(() => {
    setDate(new Date().toString()); // âœ… Only on client
  }, []);
  
  return <div>{date || "Loading..."}</div>;
}
```

## ERROR 4: "Cannot read properties of undefined (reading 'X')"

**Cause**: Accessing nested properties without null checks

**Example**:
```tsx
function UserProfile({ user }) {
  return <div>{user.profile.name}</div>; // âŒ user or profile might be null
}
```

**FIX**: Add null checks or optional chaining
```tsx
function UserProfile({ user }) {
  if (!user?.profile) return <div>No user data</div>;
  return <div>{user.profile.name}</div>; // âœ… Safe
}

// OR use optional chaining
function UserProfile({ user }) {
  return <div>{user?.profile?.name ?? "No name"}</div>; // âœ… Safe
}
```

## ERROR 5: "Text content does not match server-rendered HTML"

**Cause**: Using random values or IDs on server

**Example**:
```tsx
export default function Page() {
  const id = Math.random(); // âŒ Different on server/client
  return <div id={id}>Content</div>;
}
```

**FIX**: Use useId() or generate on client only
```tsx
"use client";

import { useId } from "react";

export default function Page() {
  const id = useId(); // âœ… Consistent
  return <div id={id}>Content</div>;
}
```

## ERROR 6: "async/await is not supported in Client Components"

**Cause**: Trying to use async function in Client Component

**Example**:
```tsx
"use client";

export default async function Page() { // âŒ Can't use async with "use client"
  const data = await fetch('/api/data');
  return <div>Data</div>;
}
```

**FIX**: Use useEffect or Server Component
```tsx
// Option 1: Remove "use client" (make it Server Component)
export default async function Page() { // âœ… Server Component can be async
  const data = await fetch('https://api.example.com/data');
  return <div>Data</div>;
}

// Option 2: Keep "use client" but fetch in useEffect
"use client";

import { useEffect, useState } from "react";

export default function Page() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/data').then(r => r.json()).then(setData);
  }, []);
  
  return <div>{data ? 'Loaded' : 'Loading...'}</div>;
}
```

## ERROR 7: "Module not found: Can't resolve 'fs'"

**Cause**: Importing Node.js modules in Client Component

**Example**:
```tsx
"use client";

import fs from 'fs'; // âŒ fs is server-only

export default function Page() {
  return <div>Page</div>;
}
```

**FIX**: Remove "use client" or move fs usage to Server Component
```tsx
// Remove "use client" - make it Server Component
import fs from 'fs'; // âœ… Works in Server Component

export default function Page() {
  const data = fs.readFileSync('./data.json', 'utf-8');
  return <div>{data}</div>;
}
```

## ERROR 8: "Accessing environment variables in Client Component"

**Cause**: Using process.env without NEXT_PUBLIC_ prefix

**Example**:
```tsx
"use client";

export default function Page() {
  const apiKey = process.env.API_KEY; // âŒ Not accessible on client
  return <div>Page</div>;
}
```

**FIX**: Use NEXT_PUBLIC_ prefix or move to server
```tsx
// Option 1: Use NEXT_PUBLIC_ prefix (if key can be public)
"use client";

export default function Page() {
  const apiKey = process.env.NEXT_PUBLIC_API_KEY; // âœ… Accessible
  return <div>Page</div>;
}

// Option 2: Use in Server Component (for secret keys)
export default function Page() {
  const apiKey = process.env.API_KEY; // âœ… Server Component can access
  return <div>Page</div>;
}
```

</common_errors_and_fixes>

<data_fetching_patterns>

## âœ… CORRECT Data Fetching

### Pattern 1: Server Component (Recommended)
```tsx
// app/users/page.tsx
export default async function UsersPage() {
  // âœ… Direct data fetching in Server Component
  const response = await fetch('https://api.example.com/users', {
    cache: 'no-store' // or 'force-cache' or revalidate: 3600
  });
  const users = await response.json();
  
  return <UserList users={users} />;
}
```

### Pattern 2: Server Actions (for mutations)
```tsx
// app/users/actions.ts
'use server';

export async function createUser(formData: FormData) {
  const name = formData.get('name');
  // Perform server-side mutation
  await db.user.create({ data: { name } });
  revalidatePath('/users');
}

// app/users/page.tsx
"use client";

import { createUser } from './actions';

export default function CreateUserForm() {
  return (
    <form action={createUser}>
      <input name="name" />
      <button>Create</button>
    </form>
  );
}
```

### Pattern 3: Route Handlers (for API routes)
```tsx
// app/api/users/route.ts
import { NextResponse } from 'next/server';

export async function GET() {
  const users = await db.user.findMany();
  return NextResponse.json(users);
}

export async function POST(request: Request) {
  const body = await request.json();
  const user = await db.user.create({ data: body });
  return NextResponse.json(user, { status: 201 });
}
```

## âŒ AVOID These Patterns

### Anti-Pattern 1: Fetching in Client Component on mount
```tsx
"use client";

import { useEffect, useState } from "react";

export default function Page() {
  const [data, setData] = useState(null);
  
  useEffect(() => {
    fetch('/api/data').then(r => r.json()).then(setData); // âŒ Bad for SEO
  }, []);
  
  return <div>{data ? 'Loaded' : 'Loading...'}</div>;
}
```

**Better**: Fetch in Server Component
```tsx
export default async function Page() {
  const data = await fetch('/api/data').then(r => r.json()); // âœ… Better
  return <div>{data}</div>;
}
```

</data_fetching_patterns>

<caching_and_revalidation>

## Next.js 15 Caching Behavior

### fetch() Options:
```tsx
// No cache (always fetch fresh)
fetch('url', { cache: 'no-store' })

// Cache forever (static)
fetch('url', { cache: 'force-cache' })

// Revalidate every N seconds
fetch('url', { next: { revalidate: 3600 } }) // 1 hour

// Revalidate with tag
fetch('url', { next: { tags: ['users'] } })
```

### Revalidation:
```tsx
// In Server Actions
import { revalidatePath, revalidateTag } from 'next/cache';

export async function updateUser() {
  await db.user.update(...);
  revalidatePath('/users'); // Revalidate specific path
  revalidateTag('users'); // Revalidate by tag
}
```

</caching_and_revalidation>

<file_structure_rules>

## âœ… CORRECT File Structure

```
app/
â”œâ”€â”€ layout.tsx          # Root layout
â”œâ”€â”€ page.tsx            # Home page
â”œâ”€â”€ api/
â”‚   â””â”€â”€ users/
â”‚       â””â”€â”€ route.ts    # API route
â”œâ”€â”€ users/
â”‚   â”œâ”€â”€ page.tsx        # /users page
â”‚   â”œâ”€â”€ layout.tsx      # Users layout
â”‚   â”œâ”€â”€ [id]/
â”‚   â”‚   â””â”€â”€ page.tsx    # /users/[id] page
â”‚   â””â”€â”€ actions.ts      # Server actions
â””â”€â”€ components/
    â””â”€â”€ user-list.tsx   # Shared component
```

## âŒ WRONG File Structure

```
app/
â”œâ”€â”€ users.tsx           # âŒ Should be users/page.tsx
â”œâ”€â”€ api/
â”‚   â””â”€â”€ users.ts        # âŒ Should be users/route.ts
â””â”€â”€ [id].tsx            # âŒ Should be [id]/page.tsx
```

</file_structure_rules>

<metadata_and_seo>

## Static Metadata
```tsx
// app/page.tsx
import { Metadata } from 'next';

export const metadata: Metadata = {
  title: 'Home Page',
  description: 'Welcome to my site',
};

export default function Page() {
  return <div>Home</div>;
}
```

## Dynamic Metadata
```tsx
// app/users/[id]/page.tsx
export async function generateMetadata({ params }: { params: { id: string } }) {
  const user = await db.user.findUnique({ where: { id: params.id } });
  
  return {
    title: user.name,
    description: `Profile of ${user.name}`,
  };
}
```

</metadata_and_seo>

<auto_fix_checklist>

When generating Next.js code, ALWAYS check:

â–¡ Is this a Client Component? â†’ Add "use client" as FIRST line
â–¡ Does it use hooks? â†’ Needs "use client"
â–¡ Does it use event handlers? â†’ Needs "use client"
â–¡ Does it use browser APIs? â†’ Needs "use client"
â–¡ Does it use async/await? â†’ Should be Server Component (no "use client")
â–¡ Does it access env vars? â†’ Use NEXT_PUBLIC_ prefix in Client or keep in Server
â–¡ Does it use useRouter? â†’ Needs "use client"
â–¡ Does it use Server Actions? â†’ Mark with 'use server'
â–¡ Are there null checks for optional props? â†’ Add ?. or if checks
â–¡ Is data fetching done correctly? â†’ Prefer Server Components
â–¡ Are dynamic values hydration-safe? â†’ Use useEffect or useId

</auto_fix_checklist>

Remember: When in doubt, make it a Server Component first. Only add "use client" when you actually need client-side interactivity!
